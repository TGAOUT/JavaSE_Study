# 目录

* [类与对象](#类与对象)
  * [类定义](#类定义)
  * [成员变量](#成员变量)
  * [方法](#方法)
  * [构造方法与对象的创建](#构造方法与对象的创建)
  * [使用对象](#使用对象)
  * [对象的引用和实体的回收](#对象的引用和实体的回收)
  * [参数传值](#参数传值)
  * [对象的组合与复用](#对象的组合与复用)
  * [实例成员和类成员](实例成员和类成员)
  * [方法重载](#方法重载)
  * [this关键字](#this关键字)
  * [访问控制修饰符](#访问控制修饰符)
* [子类与继承](#子类与继承)
  * [子类与父类](#子类与父类)
  * [子类的继承性](#子类的继承性)
  * [子类与对象](#子类与对象)
  * [成员变量的隐藏和方法重写](#成员变量的隐藏和方法重写)
  * [super关键字](#super关键字)
  * [final关键字](#final关键字)
  * [对象的上转型对象](#对象的上转型对象)
  * [继承与多态](#继承与多态)
  * [abstract类和abstract方法](#abstract类和abstract方法)
* [接口和实现](#接口和实现)
  * [接口](#接口)
  * [实现接口](#实现接口)
  * [接口回调](#接口回调)
  * [接口与多态](#接口与多态)
  * [接口参数](#接口参数)
  * [抽象类与接口的比较](#抽象类与接口的比较)
* [内部类与异常类](#内部类与异常类)
  * [内部类](#内部类)
  * [匿名类](#匿名类)
  * [异常类](#异常类)
  * [断言](#断言)

# 类与对象

类是java中最重要的数据类型，类声明的变量被称为对象变量，简称对象。

## 类定义

类的定义包括两部分：类声明和类体。基本格式如下：

```
class 类名{
    类体的内容
}

class是关键字，用来定义类，"class 类名"是类的声明部分，类名必须是合法的标识符，类名的每个单词的首字母大写。

两个大括号及其之间的内容是类体。
类体的内容有两部分构成：
1. 变量的声明：用来存储属性的值(体现对象的属性)
2. 方法的定义：方法可以对类中声明的变量进行操作，即给出算法(体现对象所有具有的行为)
```

## 成员变量

类中声明的变量被称为成员变量或域变量。

成员的变量的类型可以是java中的任何一种类型，包括基本类型：整型，浮点型，布尔型，字符型；引用类型：数组，对象，接口。例如：

```
class Factory{
    float [] a;
    Workman zhang;
}
class Workman{
    double x;
}
```

`Factory`类的成员变量a是float型；zhang是`Workman`类声明的变量，即对象。

成员变量在整个类内都有效，与它所声明的位置无关。

**编程风格：**

* 一个变量占一行，利于给代码添加注释
* 第一单词首字母小写，之后的单词首字母大写
* 见名知意

## 方法

方法的定义包括两部分：方法头和方法体。

### 方法头

方法头由方法返回的类型、名称和名称之后的一对小括号及其中的参数列表构成。

```
int speak(){
    return 23333;
}
int add(int x,int y,int z){
    return x+y+z;
}
```

方法返回的数据类型可以是java中的任何一种数据类型，当一个方法是`void`类型时，该方法不返回数据。

参数是逗号隔开的一些变量声明，可以是任意的Java数据类型。

### 方法体

方法体中包括局部变量和java语句，在方法体中可以对成员变量和局部变量进行操作。

局部变量包括方法头的参数列表和方法体中声明的变量。

```
int getSum(int n){  #n局部变量
    int sum = 0; #sum局部变量
}
```

**和成员变量不同的是，局部变量只在方法内有效，而且与其声明的位置有关。**

**方法的参数在整个方法内有效，方法内的局部变量从声明它的位置之后开始有效。**

**如果局部变量的声明是在一个符复合语句中，那么该局部变量的有效范围是该复合语句。**

**如果局部变量的声明在一个循环语句中，那么该局部变量的有效范围是该循环语句。**

例如：

```
public class A{
    int m = 10;
    int sum = 0; #成员变量在整个类中有效
    void f(){
        if(m>9){
            int z = 10;  # z仅仅在该复合语句中有效
            z = 2*m+z;  
        }
        for(int i = 0;i<m;i++){
            sum = sum + i; # i仅仅在该循环语句中有效
        }
        m = sum; # 合法，因为m和sum有效
        z = i + sum;  #不合法，因为i和z已经无效
    }
}
```

**成员变量和局部变量除了有效范围不一样，还有2个区别：**

如果局部变量的名字和成员变量的名字相同，那么成员变量被隐藏，即成员变量在这个方法内暂时失效。

如果想要在该方法中使用被隐藏的成员变量，必须使用关键字`this`，例如：

```
class Tom{
    int x =10;
    void f(){
        int x = 5;
        int y;
        y = x + this.x; //得到的值是15
    }
}
```

**另外一个区别**

成员变量可以没有默认值，但是局部变量在使用之前必须有个初始值，否则编译将会出错。

## 构造方法与对象的创建

### 构造方法

类中构造方法的名字**必须和它所在的类的名字完全相同，而且没有类型。有类型的不是构造方法**

允许在一个类中**编写若干个构造方法，但必须保证他们的参数不同**，

参数不同是指：**参数的个数不同或参数的个数相同，但参数列表中对应的某个参数类型不同**

需要注意的是，如果类中**没有编写构造方法**，系统**会默认该类中只有一个构造方法，该默认的构造方法时无参数的，且方法体中没有语句**，例如：

```
class Loader{
    Loader(){
    }
}
```

### 创建对象

 创建对象包括对象的声明和为对象分配变量两个步骤

对象声明的格式：`类的名字 对象名字`，此时只是个空对象，空对象不能使用。

为对象分配变量：使用new运算符和类的构造方法为声明的对象分配变量，即创建对象。

例如：

```
class A{
    float height,weight;
    String head,ear;
    void speak(String s){
        System.out.println(s)
    }
}
class B{
    public static void main(String args[]){
        A a;  #声明对象
        a = new A();  #为对象分配变量
    }
}
```

上述代码在执行`new A()时`，会做两件事：

（1）为`height,weight,head,ear`各个变量分配内存，即A类的成员变量被分配内存空间，然后执行构造方法中的语句。如果成员变量在声明时没有指定初值，所使用的构造方法也没有对成员变量进行初始化操作，那么对整型的成员变量，默认初值是0；对于浮点型，默认初值是0.0；对于boolean型，默认是false；对于引用型，默认初值是null。

（2）new运算符在为变量`height,weight,head,ear`分配内存后，将计算出一个称作引用的值(该值包含着代表这些成员内存位置及相关的重要信息)，即表达式`new A()`是一个值，如果把该引用赋值给a:

` a = new A(); `

那么Java系统分配的 `height,weight,head,ear`的内存单元将由a操作管理，称`height,weight,head,ear`是属于对象a的实体，即这些变量是属于a的，所谓创建对象就是指为对象分配变量，并获得一个引用，以确保这些变量由该对象来操作管理。

## 使用对象

对象操作自己的变量：`对象.变量；`

对象调用类中的方法：`对象.方法；`

另外`new A().height = 100`也是成立的。

`new A（）`实际上也是一个对象，只不过没有赋值给一个对象变量，被称为匿名对象，不好使，勿用。

## 对象的引用和实体的回收

分配给对象的变量被习惯地称作对象的实体

空对象是没有实体的对象，不要使用空对象，否则会抛出异常

一个类声明的两个对象如果具有相同的引用，二者就具有完全相同的变量(实体)。例如：

```
Point p1 = new Point(5,15);
Point p2 = new Point(8,18);
目前上述两个对象分别对应着两个不同的引用

p1 = p2;
执行上述代码后，p1和p2的引用相同。而之前p1中的实体不再被任何对象所拥有，无疑在浪费内存。
由于Java的类中没有析构函数，但具有"垃圾回收机制"，Java系统若发现堆中分配的实体不再被栈中任何对象引用时，就会释放该实体在堆中占用的内存。
如果希望Java虚拟机立刻进行"垃圾收集"操作，可以让System类调用gc()方法
```

## 参数传值

方法被调用时，调用者必须向参数传递值。

### 传值机制

方法中参数变量的值都是调用者指定值的拷贝。

例如，如果向int型参数x传递一个int值，那么参数x得到的值是传递值的拷贝。因此，若在方法内改变参数的值，不会影响向参数"传值"的变量的值，反之亦然。

### 基本数据类型参数的传值

对于基本类型的参数，向该参数传递的值的级别不可以高于该参数的级别。

例如：

不可以向`int`型参数传递一个`float`值，但可以向`double`型传递一个`float`值

**基本数据类型级别由低到高排列如下**：

`byte short char int long float double `

### 引用类型参数的传值

当参数是引用类型时，"传值"传值的是变量中存放的"引用"，而不是变量所引用的实体。

需要注意的是：对于两个相同类型的引用型变量，如果具有同样的引用，就会用同样的实体，

因此，如果改变参数变量所引用的实体，就会导致原变量的实体发生同样的变化，

但是，改变参数中存放的"引用"不会影响向其传值的变量中存放的"引用"，反之亦然。

### 可变参数

可变参数是指在声明方法时不给出参数列表中**从某项开始直至最后一项参数的名字和个数**，但这些参数的类型必须相同。

可变参数使用`...`表示若干个参数，这些参数的类型必须相同，例如：

`void f(int ... x)`

那么，方法f的参数列表中，**从第一个至最后一个参数都是int型**，但是连续出现的int型参数的个数不确定，所以x是方法f的参数列表中可变参数的代表。

再如：`void g(double a,int ... x)`

那么，方法g的参数列表中，**从第二个至最后一个参数都是int型**，但是连续出现的int型参数的个数不确定，所以x是方法g的参数列表中可变参数的代表。**参数代表必须是参数列表的最后一个**

可以把可变参数当做为数组：

```
x.length  //表示参数个数
x[0]  //表示可变参数的第一个参数
x[x.length-1]  //表示可变参数的最后一个参数

也可以使用for语句循环可变参数值，例如
int getSum(int ... x){
    int sum = 0;
    for(int a:x){
        sum +=a
    }
}
```

## 对象的组合与复用

一个类把某个对象作为自己的一个成员变量，如果用这样的类创建对象，那么该对象中就会有其他对象，这就是对象的组合。

如果一个对象a组合对象b，那么对象a就可以委托对象b调用其方法，即对象a以组合的方式复用了对象b的方法

通过组合对象来复用有以下特点：

（1）通过组合对象来复用方法也称"黑盒"复用，因为当前对象只能委托所包含的对象调用其方法，这样一来，当前对象对所包含的对象的方法的细节是一无所知的

（2）当前对象随时可以更换所包含的对象

## 实例成员和类成员

### 实例变量和类变量的声明

```
class A{
    float x;  //实例变量
    static int y;  //由static修饰的变量称为类变量或者静态变量
}
```

### 实例变量和类变量的区别

* 不同对象的实例变量互不相同

  一个类可以通过new创建多个对象，并且会为对象中的实例变量分出内存，不同对象的实例变量被分配的内存块不一样，即他们的实例变量影响。

* 所有对象共享类变量

  当使用new创建多个对象时，分配给这些对象的这个类变量占有相同的内存，任意一个对象的改变类变量，其他对象的类变量也会被改变。

* 通过类名直接访问类变量

  实例变量只能通过对象访问，但类变量还可以通过类名直接访问

  ```
  A a= new A();
  a.x = 12.1f;  //通过对象名访问实例变量
  
  a.y = 12;
  A.y = 12;  //既可以通过对象访问，也可以通过类名访问
  ```

### 实例方法和类方法的定义

```
class A{
    int a;
    float max(float x,float y){  //实例方法
       ...
    }
    static void speak(String s){  //类方法
       ...
    }
}
```

### 实例方法和类方法的区别

* 对象调用实例方法

  实例方法只能通过对象调用，实例方法可以操作实例变量也可以操作类变量

* 类名调用类方法

  类方法可以通过对象调用，也可以通过类名调用。

  类方法只能操作类变量，不能操作实例变量

## 方法重载

Java中存在两种多态：重载与重写。重写是继承有关的多态，在之后补，这里先说重载。

方法重载的意思是：一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同。

两个方法的参数不同是指满足下列之一：

* 参数的个数不同
* 参数的个数相同，但参数列表中对应的某个参数的类型不同

**注**：**方法的返回类型和参数的名字不参与比较**，也就是说，如果两个方法的名字相同，即使返回类型不同，也必须保证参数不同

## this关键字

this是Java中的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中**，但不可以出现在类方法中。**

当实例成员变量的名字和局部变量的名字相同时，可以使用this关键字来区别实例变量和酷不变量。

## 访问控制修饰符

Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。

* default(即默认，什么也不写)：在同一个包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
* private：在同一个类中可见。使用对象：变量、方法。**注意不能修饰类(外部类)**
* public：对所有类可见。使用对象：类、接口、变量、方法
* protected：对同一包内的类和所有子类可见。使用对象：变量、方法。**注意不能修饰类(外部类)**

我们可以通过下表来说明访问权限：

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| ----------- | ------ | -------- | -------------- | ------------------------------------------------------------ | ------ |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
| `default`   | Y      | Y        | Y              | N                                                            | N      |
| `private`   | Y      | N        | N              | N                                                            | N      |

### project修饰符

主要记录Protected修饰符，其他修饰符见上表即可。

在很多地方，出现过这样一句话："**protected： 同一个包内或者不同包内的子类可以访问。**  "

不知道能害死多少人。

重新认识一下`protected`修饰符

思考几个问题：

* 同一包中，任何类可以访问某类的parent方法吗

* 同一个包内，子类对象能访问父类的protected方法吗？
* 不同包下，在子类中创建该子类对象能够访问父类的protected方法吗？
* 不同包下，在子类中创建父类对象能访问父类的protected方法吗？
* 不同包下，在子类中创建另一个子类的对象能访问公共父类的protected方法吗？

---

**创建一个类Parent，所在包parentpackage**：

```
package parentpackage;
public class Parent {
    protected String protect = "protect field";
    protected void getMessage(){
        System.out.println("i am parent");
    }
}
```

**在同包写个测试类Test：**

```
package parentpackage;
public class Test{  //class Test{, final class Test{
    public static void main(String[] args) {
 		Parent parent = new Parent();
        parent.getMessage();
    }
}
```

**测试结果：**编译运行成功

**小结论：**同一包中，在任何类中创建Parent的对象可以访问Parent类的parent方法,这个类可以是友好类，final类，public类

----

**在同包中写一个Parent类的子类Test：**

```
package parentpackage;
public class Test extends Parent{
    public static void main(String[] args) {
        Test test = new Test();
        test.getMessage();

 		Parent parent = new Parent();
        parent.getMessage();
    }
}
```

**测试结果：编译运行成功**

**小结：在同一个包中，子类中创建的子类对象可以访问父类中的protected方法。**

---

**在不同包中创建一个Parent类的子类Son1:**

```
package parentpackage.sonpackage1;
import parentpackage.Parent;

public class Son1 extends Parent{
    public static void main(String[] args) {
        Parent parent1 = new Parent();   //1.声明了Parent类型变量
        parent1.getMessage();            //2.调用Parent中的getMessage()方法

        Parent parent2 = new Son1();     //3.声明Parent类型变量
        parent2.getMessage();            //4.调用Parent中的getMessage()方法
    }
}
```

**测试结果：**

* 1和3都声明了`Parent`类型变量，只不过创建对象的方式不一样，编译可以通过
* 但是2和4，调用`Parent`中的被`protected`修饰的`getMessage()`方法，编译无法通过。

**小结：**

**不同包下，在子类中创建父类对象(声明父类类型的变量)不能访问父类的protected方法**

---

**修改Parent类的子类Son1：**

```
package parentpackage.sonpackage1;
import parentpackage.Parent;

public class Son1 extends Parent{
    public static void main(String[] args) {
        Son1 test = new Son1();
        test.getMessage();
    }
}
```

**测试结果：编译运行通过**

**小结：不同包，在子类中创建子类对象可以访问父类中被protected的方法。**

---

**创建Parent类的另一个子类Son2:**

```
package parentpackage.sonpackage1;
import parentpackage.Parent;

public class Son2 extends Parent {

}

```

**修改Parent类的子类Son1：**

```
package parentpackage.sonpackage1;

import parentpackage.Parent;
import parentpackage.sonpackage1.Son2;

public class Son1 extends Parent{
    public static void main(String[] args) {
        Son2 son2 = new Son2();
        son2.getMessage(); //错误
    }
}
```

**测试结果：编译出错**

**小结：在不同包中，在子类中创建另一个子类的对象无法访问它们共同的父类中的方法。**

---

**总结：**

**在同包下，在任何类中创建某个类的对象都可以访问这个类的 protected成员。**

**在同包下，在子类中创建父类的对象或者子类对象或者其他子类的对象都可以访问父类的protected成员。**

**在不同包下，在子类中创建子类对象可以访问父类的protected成员。**

**在不同包下，在子类中创建父类对象不能访问父类的protected成员。**

**在不同包下，在子类中创建另一个子类的对象不能访问父类的protected成员。**



# 子类与继承

## 子类与父类

在类的声明中，通过关键字`extends`来定义一个类的子类，格式如下：

```
class 子类名 extends 父类名{
    
}
```

如果c是B的子类，B又是A的子类，习惯上称C是A的子孙类。Object类是java.lang包中的类，它是所有类的祖先类，任何类都是Object类的子孙类，每个类有且仅有一个父类，一个类可以有多个或零个子类，如果一个的声明中，没有使用extends关键字，这个类被系统默认为是Object的子类。

## 子类的继承性

子类中的实例方法能够操作父类的成员变量，如果不能操作，即该成员变量没有被继承。

所谓子类继承父类的方法作为子类中的一个方法，就像他们是在子类中直接定义了一样，可以被子类中自己定义的任何实例方法调用。

### 子类和父类在同一个包中的继承性

如果子类和父类在同一个包中，那么，子类自然地继承了其父类中不是private的成员变量和成员方法。

继承的成员变量或方法的访问权限保持不变。

### 子类和父类不在同一个包中的继承性

当子类和父类不在同一个包中时，父类中的private和友好访问权限的成员变量不会被子类继承，也就是说，子类只继承了父类中的protected和public访问权限的成员变量作为子类的成员变量；同样，子类只继承父类中的protected和public访问权限的方法作为子类的方法。

## 子类与对象

### 子类对象的特点

当子类对象利用构造方法创建一个子类对象时，系统不仅为子类的成员变量分配内存，而且也为父类的成员变量分配内存，但是子类或多或少地不能继承父类的某些变量，在同一个包中，父类的private变量无法继承，在不同的包中，父类的友好变量也无法继承。

这样貌似觉得这么没有被子类继承的变量在浪费内存，其实虽然这些父类的成员变量无法被子类继承，但是子类继承父类中的方法，可以操作这些没继承的成员变量。

### 关于instanceof运算符

instanceof运算符是二目运算符，左面的操作元是对象，右面的操作元是类。

当左面的操作元是右面的类或者其子类所创建的对象时，instanceof的值是true，否则是false。

## 成员变量的隐藏和方法重写

### 成员变量的隐藏

起因：由于子类定义的成员变量与从父类继承过来的成员变量的名字相同(**声明的类型可以不同**)，在这情况下，子类就会**隐藏**所继承的成员变量。

子类隐藏继承的成员变量的特点如下：

* 子类对象以及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量。
* 子类对象仍然可以调用从父类继承的方法操作被子类隐藏的成员变量，也就是说，子类继承的方法所操作的成员变量一定是被子类继承或隐藏的成员变量。

### 成员方法的隐藏(方法重写)

子类通过重写可以隐藏已继承的方法(方法重写称为方法覆盖)

重写条件，如果子类可以继承父类的某个方法，那么子类就有权利重写这个方法。

**重写的语法规则：**

* 重写的方法返回类型与父类的方法返回类型一致
* 重写的方法名与父类的方法名一致
* 重写的方法中参数个数、参数类型与父类方法一致

**重写的目的：**

* 改变自身的状态和行为

**重写的特点：**

重写方法既可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员变量、调用新定义的其他方法，但无法操作被子类隐藏的变量和方法。**如果子类想使用被隐藏的方法或成员变量，必须使用关键字super**

**重新注意事项：**

重写父类的方法时，不允许降低方法的访问权限，但可以提高访问权限。

访问限制修饰符按访问权限从高到低的排列顺序是public、protected、友好的、private。

## super关键字

### 用super操作被隐藏的成员变量和方法

子类一旦隐藏了继承的成员变量和成员方法，那么子类创建的对象就不再拥有该成员变量和成员方法，该成员变量和成员方法归关键字super所拥有，通过super.x、super.play()就是访问和调用被子类隐藏的成员变量x和方法play()。

### 使用super调用父类的构造方法

当用子类的构造方法创建一个子类的对象时，子类的构造方法总是先调用父类的某个构造方法。

如果子类的的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法。

由于子类不继承父类的构造方法，因此，子类在其构造方法中需使用super来调用父类的构造的方法；

而且super必须是子类构造方法中的头一条语句；即如果在子类的构造方法中，没有明显地写出super关键字来调用父类的某个构造方法，默认地有`super();`，调用父类的不带参数的构造方法。

**注意：**

因此，当在父类中定义多个构造方法时，应当包括一个不带参数的构造方法，以防止子类省略super时出现错误。

## final关键字

final关键字可以修饰变量、方法、类。

### final变量

final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 

final 修饰符通常和 static 修饰符一起使用来创建类常量。 

### final方法

父类中的 final 方法可以被子类继承，但是不能被子类重写。

声明 final 方法的主要目的是防止该方法的内容被修改。

### final 类

final 类不能被继承，没有类能够继承 final 类的任何特性。

## 对象的上转型对象

```
Animal a = new Tiger();
或者
Animal a;
Tiger b = new Tiger();
a = b;
```

这时，称对象a是对象b的上转型对象

对象的上转型对象的实体是子类的负责创建的，但上转型对象会失去原对象的一些属性和功能。

（1）上转型对象不能操作子类新增的成员变量(失掉了这部分属性)，不能调用子类新增的方法(失掉了一些行为)

（2） 上传型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类重写的实例方法。

上传型对象操作子类的继承的方法或子类重写的实例方法，**其作用等价于子类对象去调用这些方法。**

因此，如果子类重写了父类的某个实例方法后，当对象的上转型对象调用这个实例方法时一定是调用了子类重写的实例方法。

**注：**

* 不要将父类创建的对象和子类对象的上转型对象混淆
* 可以将对象的上转型对象再强制转换到一个子类对象，这时，该子类对象又具备了子类所有的属性和功能
* 不可以将父类创建的对象的引用赋值给子类声明的对象
* 如果子类重写了父类的静态方法，那么子类对象的上转型对象不能调用子类重写的的静态方法，只能调用父类的静态方法。

## 继承与多态

当一个类有很多子类时，并且这些子类都重写了父类的某个方法。

那么当把子类创建的对象的引用放到一个父类的对象时，就得到了该对象的一个上转型对象，那么这个上转型对象在调用这个方法时就可能具有多种形态。

因为不同的子类在重写父类的方法时可能产生不同的行为。

## abstract类和abstract方法

**用关键字abstract修饰的类称为abstract类(抽象类)，例如：**

```
abstract class A{
    ...
}
```

* abstract类中可以有abstract方法，可以有非abstract，可以无abstract方法。
* abstract类不能用new运算符创建对象，**如果一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体**，这就是为什么**不允许使用final和abstract同时修饰一个方法或类的原因**。
* 如果一**个非abstract类是abstract类的子类，它必须重写父类的abstract的方法**，即去掉abstract修饰，给出方法体。**如果一个abstract类是abstract类的子类，它可以重写父类的abstract方法，也可以继承父类的abstract方法。**
* 可以使用abstract类声明对象，尽管不能使用new运算符创建改对象，但**该对象可以成为其子类对象的上转型对象，那么改对象就可以调用子类重写的方法**。

**用关键字abstract修饰的方法称为abstract方法(抽象方法)，例如：**

```
abstract int min(int x,int y);
```

对于abstract方法，**只允许声明，不允许实现(没有方法体)**；而且**不允许使用final和abstract同时修饰一个方法或类**，也**不允许使用static修饰abstract方法**，即abstract方法必须是实例方法。

### 抽象类的特点：

* 抽象类和抽象方法必须用abstract关键字修饰
* 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者接口
* 抽象类不能实例化，也就是说不能new出来，抽象类必须由子类实例化，这其实也就是多态的一种，抽象类多态（**为什么抽象类不能实例化？** **如果抽象类实例化，实例化的抽象类对象意思就可以调用抽象类的抽象方法，但是抽象方法是没有具体实现的，也就没有任何意义，所以抽象类不能实例化**）
* 抽象类的子类要么是抽象类(实例中的Car类)，要么就重写抽象类中的抽象方法（实例中的Jetta类）
* 一个类只能继承一个抽象类，抽象类也可以继承抽象类（实例中的SuperCar 类）

### 抽象类成员特点：

* 成员既可以是常量也可以是变量，但是abstract不能修饰成员变量，变量的值是不固定的，无法抽象
* 抽象类也有构造方法，他的意义在于子类可以访问父类的初始化数据
* 成员方法既可以抽象的，也可以是非抽象的，**抽象方法一般是强制要求子类去实现的方法，非抽象方法一般是重复的代码，可以提高代码复用性**
* abstract关键字不能与static关键字（原理和抽象类不能实例化其实是一个道理，**static修饰的抽象方法不需要实例化可以直接调用，这显然是没有意义的**）、final关键字(**final修饰的方法子类不能重写，abstract修饰的方法子类强制重写**)、private关键同时出现（**private修饰的方法子类不能访问**）

 

# 接口与实现

## 接口

使用关键字interface来定义一个接口

```
interface A{
    final int MAX = 100;
    void add();
    float sum(float x,float y);
}
```

### 接口声明

定义接口包含接口声明和接口体：

```
interface 接口的名字
```

### 接口体

接口体中包含常量的声明(没有变量)和抽象方法两部分。接口体中只有抽象方法，没有普通方法，**而且接口体中所有的常量的访问权限一定都是public，而且是static常量**(允许**省略public、final和static修饰符**)，**所有的抽象方法的访问权限一定都是public**(允许**省略public abstract修饰符**)；

### 接口的特点：

- 接口使用interface关键字代替class修饰类，
- 类实现接口用implement表示
- 和抽象类一样，接口也不能实例化，只能由实现了接口的类来进行实例化
- 接口的子类可以是抽象类，也可以是具体类，具体类要重写接口的抽象方法

### 接口成员特点：

- 接口中定义的变量都是常量，**默认修饰符为 public static final**
- 接口没有构造方法，**方法默认修饰符public abstract**

## 实现接口

### 类实现接口

使用关键字implements声明该类实现一个或多个接口，如果实现多个接口，用逗号隔开接口名。

`class A implements C,B`

### 重写接口中的方法

* 一个非抽象类实现某个接口，那么这个类**必须重写这个接口中的所有方法**
* **接口中的方法一定是public abstract方法**，重写时去掉abstract，且public修饰符不能省略，否则降低了访问权限
* 实现接口的非抽象类实现了该接口中的方法，即给出了方法的具体行为功能
* 如果一个类声明实现了一个接口，但是没有重写接口中的所有方法，那么这个类必须是抽象类，也就是说，抽象类皆既可以重写接口中的方法，也可以直接拥有接口中的方法。

### 接口的细节说明

程序可以用接口名访问接口中的常量，但是如果一个类实现了接口，那么该类可以直接在类体中使用该接口中的常量。

定义接口时，如果关键字interface前面加上public关键字，就称这样的接口是一个public接口。public接口可以被任何一个类实现。如果一个接口不加public修饰，就称作友好接口，友好接口可以被与该接口在同一个包中的类实现。

如果父类实现了某个接口，那么子类也自然实现了该接口，子类不必再显示地使用关键字implements声明实现这个接口。

接口也可以被继承，即可以通过关键字extends声明一个接口是另一个接口的子接口。由于接口中的方法和常量都是public的，子接口将继承父接口中的全部方法和常量。

**注：**Java提供的接口都在相应的包中，通过import语句不仅可以引入包中的类，也可以引入包中的接口，例如：

`import java.io.*;`不仅引入了java.io包中的类，同时也引入了该包中的接口。

## 接口回调

接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用，即存放对象的引用。比如，假设com是一个接口，那么就可以用Com声明一个变量：

`Com com;`

称此时的com是一个空接口，因为com变量中还没有存放实现该接口的类的实例的引用。

---

`ImpleCom object = new ImpleCom();`

假设ImpleCom类实现了Com接口的类，用ImpleCom创建名字为objet的对象，那么object对象不仅可以调用`ImpleCom`类中原有的方法，而且也可以调用ImpleCom类实现的接口方法。

----

`com = object;`

接口回调是指：可以把实现某一接口的类创建的对象的引用赋值给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口方法。实际上，当接口变量调用被类实现的接口方法时，就是通知相应的对象调用这个方法

**注：**接口变量无法调用类中的其他的非接口方法。

## 接口与多态

把实现某一接口的类创建的对象的引用赋值给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口方法。由接口产生的多态就是指不同的类在实现同一个接口时可能具有不同的实现方式，那么接口变量在回调接口方法时就可能具有多种形态。

## 接口参数

如果一个方法的参数是接口类型，我们就可以将任何实现该接口的类的实例的引用传递给该接口参数，那么接口参数就可以回调类实现的接口方法。

## 抽象类与接口的比较

相同：

* 抽象类和接口都可以有抽象方法

不同：

* 抽象类可以有默认方法，也可以有抽象方法；接口时抽象方法的集合
* 实现抽象类使用**extends**关键字来继承**抽象类**。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字**implements**来实现**接口**。它需要提供接口中所有声明的方法的实现。
* 抽象类可以有构造器(抽象类本质还是类，只不过不能new)；接口不能构造器。
* 抽象方法可以有public、protected、default这些修饰符；接口方法默认修饰符就是public，不可以使用其它修饰符。
* 抽象类表示的是一种继承关系，一个类只能存在一个父类，但是可以存在多个接口。
* 抽象方法比接口速度快，接口时稍微慢的，因为它需要时间去寻找类中实现的方法。
* 如果向抽象类中添加新的方法，你可以给它提供默认的实现(抽象类中可以存在一些非抽象的方法)，不需要在继承它的子类中去实现，因此你不需要改变你现在的代码。如果你向接口中添加方法，那么必须改变实现该接口的类
* 抽象类成员变量可以是常量，也可以变量；接口成员变量只能是常量。

# 内部类与异常类

## 内部类

Java支持在一个类中定义另一个类，这样的类称作内部类，而包含内部的类称为内部类的外嵌类

内部类和外嵌类之间的重要关系如下：

* 内部类的外嵌类的成员变量在内部类仍有效，内部类中的方法也可以调用外嵌类中的方法
* 内部类的类体中不可以声明类变量和类方法。外嵌类的类体中可以用内部类声明对象，作为外嵌类的成员。
* 内部类仅供它的外嵌类使用，其他类不可以用某个类的内部类声明对象。

内部类字节码文件名：**外部类$内部类**

## 匿名类

### 和子类有关的匿名类

假设Bank是类，那么下列代码就是用Bank的一个子类(匿名类)创建对象。

```
new Bank(){
  匿名类的类体  
};
```

匿名类有以下特点：

* 匿名类可以继承父类的方法也可以重写父类的方法
* 使用匿名类时，必然是在某个类中直接用匿名类创建对象，因此匿名类一定是内部类
* 匿名类可以访问外嵌类中的成员变量和方法，匿名类中不可以声明static成员变量和static方法
* 由于匿名类是一个子类，但是没有类名，所以在用匿名类创建对象时，要直接使用父类的构造方法

有以下方法：

```
void f(A a){
    
}
```

该方法的参数类型是A类，用户希望向方法传递A的子类对象，此时便可以创建A的子类(匿名类)，如下:

```
f(new A(){继承父类的匿名类类体});
```



### 和接口有关的匿名类

假设Computable是一个接口，那么，Java允许直接用接口名和一个类体创建一个匿名对象，如下:

```
new Computable(){
    实现接口的匿名类的类体
};
```

如果某个方法的参数是接口类型，比如**void f(Computable x)**

那么在调用f时，可以向f的参数x传递一个匿名对象，如：

```
f(new Computable(){实现接口的匿名类类体})；
```

## 异常类

### try-catch语句

Java使用try-catch语句来处理异常，将可能出现的异常操作放在try-catch语句的try部分，

一旦try部分抛出异常对象，或者调用某个可能抛出异常对象的方法，并且该方法抛出了异常对象，

那么try部分将立刻结束执行，转而执行相应的catch部分。

所以程序可以将发生异常后的处理方法catch部分。

try-catch语句可以由几个catch组成，分别处理发生的相应异常。

格式如下：

```
try{
    包含可能发生的异常语句
}
catch(ExceptionSubClass1 e){
    e.getMessage();
}
catch(ExceptionSubClass2 e){
    e.printStackTrace();
}
catch(ExceptionSubClass3 e){
    e.toString();
}
```

各个catch参数中的异常类都是`Exception`的某个子类(它们之间不能有父子关系)，

表明try部分可能发生的异常，try处抛出的异常对象在catch中匹配，

然后进一步处理，

比如：利用匹配到的异常对象掉用`getMessage、printStackTrace、toString()`得到或输出有关异常的信息

### 自定义异常类

在编写程序时可以扩展`Exception类定义自己的异常类`，然后根据程序的需要来规定哪些方法产生这样的异常。

一个方法在声明时可以使用`throws`关键字声明要产生的若干个异常类，并在该方法中的方法体中具体给出产生异常时的操作，即用相应的异常类创建对象，并使用`throw`关键字抛出该异常对象，导致该方法结束执行。

程序必须在`try-catch`块语句中调用可能发生异常的方法，其中`catch`的作用就是捕获`throw`关键字抛出的异常对象。



## 断言

### 语法格式

断言语句在调式代码时特别有用，具有两种形式

```
1. assert booleanExpression;
2. assert booleanExpression:messageException;
```

如果使用上述第一种形式，当` booleanExpression`的值是`true`时,程序从断言语句处继续执行；值是`false`时，程序从断言语句处停止执行.

如果使用上述第二种形式，当` booleanExpression`的值是`true`时,程序从断言语句处继续执行；值是`false`时，程序从断言语句处停止执行，并输出`messageException`的值，提示用户出现的问题。

### 启用于关闭断言语句

当使用Java解释器直接运行应用程序时，默认地关闭断言语句，在调试程序时可以使用`-ea`启用断言语句，例如：

`java -ea mainClass`







